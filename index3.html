<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <title></title>
    <style>
      body{
        margin: 0;
        overflow: hidden;
      }
      #addCube {
        position: absolute;
        top: 10px;
        left: 10px;
      }
      #addCircle {
        position: absolute;
        top: 40px;
        left: 10px;
      }
    </style>
  </head>
  <body>
    <div id="viz"></div>
    <button id="addCube">Add Cube</button>
    <button id="addCircle">Add Circle</button>
    <script>
      /*
       * Debug parameters.
       */
      WebVRConfig = {
        /**
         * webvr-polyfill configuration
         */
        // Forces availability of VR mode.
        FORCE_ENABLE_VR: true, // Default: false.
        // Complementary filter coefficient. 0 for accelerometer, 1 for gyro.
        //K_FILTER: 0.98, // Default: 0.98.
        // How far into the future to predict during fast motion.
        //PREDICTION_TIME_S: 0.040, // Default: 0.040 (in seconds).
        // Flag to disable touch panner. In case you have your own touch controls
        //TOUCH_PANNER_DISABLED: true, // Default: false.
        // Enable yaw panning only, disabling roll and pitch. This can be useful for
        // panoramas with nothing interesting above or below.
        //YAW_ONLY: true, // Default: false.
        /**
         * webvr-boilerplate configuration
         */
        // Forces distortion in VR mode.
        //FORCE_DISTORTION: true, // Default: false.
        // Override the distortion background color.
        // DISTORTION_BGCOLOR: {x: 1, y: 0, z: 0, w: 1}, // Default: (0,0,0,1).
        // Prevent distortion from happening.
        //PREVENT_DISTORTION: true, // Default: false.
        // Show eye centers for debugging.
        // SHOW_EYE_CENTERS: true, // Default: false.
        // Prevent the online DPDB from being fetched.
        // NO_DPDB_FETCH: true,  // Default: false.
      };
    </script>
    <script src="bower_components/three.js/build/three.js"></script>
    <script src="bower_components/jquery/dist/jquery.js"></script>
    <script src="node_modules/three/examples/js/controls/VRControls.js"></script>
    <script src="node_modules/three/examples/js/effects/VREffect.js"></script>
    <script src="node_modules/webvr-polyfill/build/webvr-polyfill.js"></script>
    <script src="build/webvr-manager.js"></script>
    <script type="text/javascript">

      var camera, controls, scene, renderer, manager;
      function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setClearColor(0xEEEEEE);

        document.getElementById("viz")
            .appendChild(renderer.domElement);

        controls = new THREE.VRControls(camera);

        var effect = new THREE.VREffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);

        manager = new WebVRManager(renderer, effect, {
          hideButton: false, // Default: false.
          isUndistorted: false // Default: false.
        });

        var axes = new THREE.AxisHelper(20);
        scene.add(axes);

        var planeGeometry = new THREE.PlaneGeometry(40, 20, 10, 10);
        var planeMaterial = new THREE.MeshBasicMaterial({color: 0xcccccc});
        var plane = new THREE.Mesh(planeGeometry, planeMaterial);

        plane.rotation.x = -0.5 * Math.PI;
        plane.position.x = 0;
        plane.position.y = 0;
        plane.position.z = 0;
        scene.add(plane);

        $("#addCube").click(function() {
          var cubeSize = Math.ceil((Math.random() * 1));
          var cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
          var materials = [
            new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff}),
            new THREE.MeshBasicMaterial({color: 0x000000, wireframe: true})
          ];
          var cube = THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, materials); //new THREE.Mesh(cubeGeometry, cubeMaterial);

          cube.castShadow = true;
          placeMesh(cube);
        });

        $("#addCircle").click(function() {
          var radius = Math.ceil((Math.random() * 5));
          var segments = Math.ceil((Math.random() * 100));
          var circleGeometry = new THREE.CircleGeometry(radius, segments);
          var material = new THREE.MeshBasicMaterial({color: Math.random() * 0xffffff});

          var circle = new THREE.Mesh( circleGeometry, material );
          placeMesh(circle);
        });

        function placeMesh(mesh) {
          mesh.name = "cube-" + scene.children.length;
          mesh.position.x = -5 + Math.round((Math.random() * 10));
          mesh.position.y = -5 + Math.round((Math.random() * 10));
          mesh.position.z = -10;// + Math.round((Math.random() * planeGeometry.parameters.height));
          mesh.rotation.y = Math.random() * 2 * Math.PI;
          mesh.rotation.z = Math.random() * 2 * Math.PI;
          scene.add(mesh);
        }
      }

      function animate() {
        requestAnimationFrame( animate );
        controls.update(); // required if controls.enableDamping = true, or if controls.autoRotate = true
        manager.render(scene, camera);
      }

      window.onload = function() {
        init();
        animate();
      }
    </script>
  </body>
</html>
